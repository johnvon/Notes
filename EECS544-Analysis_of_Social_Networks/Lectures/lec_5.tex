\chapter{Network Partition}
\lecture{5}{15 Sep. 12:30}{Partition Networks Hierarchically}
In this chapter, we want to partition a network in order to study its structure. As we have seen before, the
notion of \hyperref[def:bridge]{bridges} and \hyperref[def:local-bridge]{local bridge} is useful in this content.

\section{Girvan-Newman Algorithm}
Firstly, a naive and simple way to partition a network is as follows.
\begin{enumerate}
	\item Remove \hyperref[def:bridge]{bridges} and \hyperref[def:local-bridge]{local bridge}.
	\item Assign importance for each node.
	      \begin{problem}
	      In what order?
	      \end{problem}
	      \begin{answer}
		      Assign importance to \hyperref[def:local-bridge]{local bridge}.
	      \end{answer}
\end{enumerate}

This idea is the backbone of the \hyperref[algo:Girvan-Newman-algorithm]{Girvan-Newman algorithm}. We first see a simple algorithmic
approach which utilize the intuition.
\begin{remark}[Algorithmic approach]
	We propose the following procedure to partition a network.
	\begin{enumerate}
		\item Rank all \hyperref[def:local-bridge]{local bridges}.
		\item Remove the highest ranked one, which yields a partition.
		\item Re-calculate ranking.
		\item Repeat from 2. until no edges remain.
	\end{enumerate}
	Note that at the end all nodes become isolated.
\end{remark}

\begin{note}
	Later, we'll (always) use pseudocodes to describe such algorithmic procedure.
\end{note}

\begin{problem}
How to rank order \hyperref[def:local-bridge]{local bridges}?
\end{problem}

\begin{intuition}
	An edge is more important if more \hyperref[def:shortest-path]{shortest paths} use it. Notice that a \emph{normalization} is needed:
	Between pairs of nodes, there should be lots of variation in the number of the \hyperref[def:shortest-path]{shortest paths} and we want to balance these out.
\end{intuition}

\subsection{Betweenness}
\begin{definition}[Betweenness]\label{def:betweenness}
	Imagine that there is a unit flow of water between each (distinct) pair of nodes. If the flow has \(k\) different ways to go to,\footnote{Actually not only depends on where can the flow go, but also where were that node added into BFS in the first place}
	we divide this unit flow into \(1/k\). We then equally divide this flow amongst the \hyperref[def:shortest-path]{shortest paths} coming out of the starting node.
\end{definition}

With the definition of \hyperref[def:betweenness]{betweenness}, we give the pseudocode of \hyperref[algo:Girvan-Newman-algorithm]{Girvan-Newman algorithm}.

\par
\begin{algorithm}[H]\label{algo:Girvan-Newman-algorithm}
	\DontPrintSemicolon
	\caption{Girvan-Newman Algorithm}
	\KwData{A network \(\mathcal{\MakeUppercase{g}} = (\mathcal{\MakeUppercase{v}} , \mathcal{\MakeUppercase{e}} ) \)}
	\BlankLine
	\SetKwFunction{calb}{Betweenness}
	\SetKwData{b}{between}

	\For{\(e\in \mathcal{\MakeUppercase{e}} \)}{
		\(\b_e\gets 0\)\Comment*[r]{Initialize \hyperref[def:betweenness]{betweenness} variable for every edge}
	}
	\;
	\While{\(\mathcal{\MakeUppercase{e}} \neq \varnothing \)}{
	\calb{\(\mathcal{\MakeUppercase{g}}\), \(\{\b_e\}_{e\in \mathcal{\MakeUppercase{e}}}\) }\Comment*[r]{Calculate \hyperref[def:betweenness]{betweenness} of all remaining edges}
	\(\b_{\text{highest}}\gets \max_{e\in \mathcal{\MakeUppercase{e}} } \b_e\)\;
	\(\mathcal{\MakeUppercase{e}}_{\text{highest} } \gets \{e\in \mathcal{\MakeUppercase{e}} \colon \b_e = \b_{\text{highest} }\}\)\;
	\(\mathcal{\MakeUppercase{e}} \gets \mathcal{\MakeUppercase{e}} \setminus \mathcal{\MakeUppercase{e}} _{\text{highest} }\)\;
	\(\mathcal{\MakeUppercase{g}} \gets \mathcal{\MakeUppercase{g}} [\mathcal{\MakeUppercase{e}}]\)\;
	}
	\Return{}\;
\end{algorithm}

\begin{remark}
	Run time analysis: \(O(\ln n)\).
\end{remark}

\begin{problem}
But how do we calculate \hyperref[def:betweenness]{betweenness} in reality?
\end{problem}

\subsection{Calculate Betweenness}
\begin{intuition}
	Use breadth-first search (BFS) in a slight different manner.
\end{intuition}
\begin{remark}
	The key is that any sub-\hyperref[def:path]{path} to destination is also a \hyperref[def:shortest-path]{shortest path}.
\end{remark}

With BFS exploration (\(i\): starting point, \(m\) is the destination), we have
\[
	\#\text{ the \hyperref[def:shortest-path]{shortest path} from \(i\) to \(m\)} =  \#\text{ the \hyperref[def:shortest-path]{shortest path} from \(i\) to \(j\)} +
	\#\text{ the \hyperref[def:shortest-path]{shortest path} from \(i\) to \(k\)}
\]
while \(j, k\) are at same level \(n-1\), and \(m\) at level \(n\), with the fact that there are edges between \(j, k\) to \(m\). This can be done by adding a \emph{counter} when
running BFS.

\subsection{Counter}
From the above equation, we will have
\[
	c_{v}^{n+1} = \sum_{v^n}c^n_{v^n}
\]
where the subscript indicates the node belongs to the counter, and \(c_v^{n+1}\) maintains the number of \hyperref[def:shortest-path]{shortest path} to \(v\), which is just \(n+1\).

The unit flow flows from nodes back from the \hyperref[def:path]{path} it is added into the BFS algorithm needs to keep its own \(1\), and then distribute.

\begin{remark}
	An algorithm for calculating the importance of each \hyperref[def:local-bridge]{local bridge}, which turns out to be \hyperref[def:betweenness]{betweenness}.
	And this is accomplished by BFS with a counter.
\end{remark}