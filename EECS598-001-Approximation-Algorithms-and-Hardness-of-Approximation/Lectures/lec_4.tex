\lecture{4}{12 Sep. 10:30}{Feedback Vertex Set}
\section{Feedback Vertex Set}

Following the discussion on primal-dual method, we see another \hyperref[def:covering]{covering} problem.

\subsection{Introduction}
We consider the following problem.

\begin{problem}[Feedback vertex set]\label{prb:feedback-vertex-set}
Given a graph \(\mathcal{\MakeUppercase{g}} = (\mathcal{\MakeUppercase{v}} , \mathcal{\MakeUppercase{e}} )\) and a weight function \(c\colon \mathcal{\MakeUppercase{v}} \to \mathbb{\MakeUppercase{r}} ^+\), we want to find \(F\subseteq \mathcal{\MakeUppercase{v}} \) with \(\min c(F)\) such that \(\mathcal{\MakeUppercase{g}} [\mathcal{\MakeUppercase{v}} \setminus F]\) has no cycle.\footnote{This is equivalent as saying that \(\mathcal{\MakeUppercase{g}} [\mathcal{\MakeUppercase{v}} \setminus F]\) is a forest.}
\end{problem}

\begin{note}[Feedback]
	The name \emph{feedback} comes from the fact that if there's a cycle in \(\mathcal{\MakeUppercase{g}} \), then it kind of creates \emph{feedback}.
\end{note}

\begin{note}[Edge version]
	The \emph{edge version} of \autoref{prb:feedback-vertex-set} can be solved by finding \(T\subseteq \mathcal{\MakeUppercase{e}} \) be the maximum weight forest,\footnote{This can be found exactly in polynomial time.} and let \(F \coloneqq \mathcal{\MakeUppercase{e}} \setminus T\).
\end{note}

\begin{notation}
	In this lecture, when talking about cycle, we're referring to the vertices in which. But the meaning can vary from context to context.
\end{notation}

\begin{remark}
	This is a \emph{special case} of \autoref{prb:set-cover}.
\end{remark}
\begin{explanation}
	Let \(\mathcal{\MakeUppercase{C}} \coloneqq \left\{ \text{set of all (simple) cycles}  \right\}\) and consider \autoref{prb:set-cover} on the set system \((\mathcal{\MakeUppercase{C}} , \mathcal{\MakeUppercase{v}} )\), i.e., we want to find \(F\subseteq \mathcal{\MakeUppercase{v}} \) such that \(\forall C\in \mathcal{\MakeUppercase{C}} \), \(\left\vert F \cap C \right\vert \geq 1\).
\end{explanation}

\begin{note}
	The naive algorithm by directly applying methods discussed for \autoref{prb:set-cover}, we see that since \(\min (\log k, d) = \Omega (n)\) for \(k\) being the maximum set size (which is \(2^{\Omega (n)}\)) and \(d = n\), the approximation ratio we can get is \(\Omega (n)\), which depends on the size of the input.
\end{note}

Now, the goal in this section is to show the following.
\begin{theorem}\label{thm:lec4-1}
	There exists a \(4\)-approximation algorithm for \autoref{prb:feedback-vertex-set}.
\end{theorem}

\begin{remark}
	Actually, there exists a \(2\)-approximation algorithm.
\end{remark}

We also have a hardness of \autoref{prb:feedback-vertex-set}.
\begin{theorem}
	A \((2 - \epsilon )\)-approximation algorithm doesn't exist for all \(\epsilon > 0\) assuming some conjecture.
\end{theorem}

\subsection{Cycle Covering LP}
The most natural LP which models \autoref{prb:feedback-vertex-set} is the so-called \emph{cycle covering LP}, which can be defined as
\begin{align*}
	\min~ & \sum_{v\in \mathcal{\MakeUppercase{V}} } c(v) x_v                                                               \\
	      & \sum_{v\in C} x_v \geq 1                         \quad \forall \text{ cycle } C \in \mathcal{\MakeUppercase{C}} \\
	      & x \geq 0,
\end{align*}
with the variables being \(\left\{ x_v \right\} _{v\in \mathcal{\MakeUppercase{v}} }\) such that \(x_{v} = \mathbbm{1}_{v\in F}\).

\begin{remark}
	We see that this cycle covering LP has \(2^{\Omega (n)}\) constraints. But we can actually solve this and get an \(O(\log n)\)-approximation ratio by smartly rounding the solution. And we can show that this approximation ratio is optimal in terms of this particular LP.
\end{remark}

\subsection{Density LP}

A more sophisticated LP is the so-called \emph{density LP}, defined as
\begin{align*}
	\min~ & \sum_{v\in \mathcal{\MakeUppercase{v}} } c(v) x_v                                                                                                  \\
	      & \sum_{v\in S} x_v(d_v^{S} - 1) \geq \left\vert E(S) \right\vert - \left\vert S \right\vert + 1\quad \forall S\subseteq \mathcal{\MakeUppercase{v}} \\
	      & x\geq 0
\end{align*}
with the variables being \(\left\{ x_v \right\} _{v\in \mathcal{\MakeUppercase{v}} }\).

\begin{notation}
	The \(E(S)\) denotes the edge set in the induced graph \(\mathcal{\MakeUppercase{g}} [S] = (S, E(S))\), while \(d_v^S\) denotes the degree of \(v\) in \(\mathcal{\MakeUppercase{g}} [S]\).
\end{notation}

\begin{intuition}
	The constraint is equivalent as  saying that for every induced graph, \(\# e \leq \# v - 1\), i.e., we require it to be a forest. Explicitly, \(S\subseteq \mathcal{\MakeUppercase{v}} \),
	\[
		\left\vert E(S) \right\vert - \sum_{v\in S} x_v d_v^S\leq \left\vert S \right\vert - \sum_{v\in S}x_v - 1.
	\]
	Note that in the constraint, the right-hand side is just a lower-bound of \(\# e\).
\end{intuition}

We see that the above LP is not exactly a \hyperref[def:covering-LP]{covering LP} since the coefficients can be negative if a set \(S\) is not \hyperref[def:irreducible]{irreducible}.

\begin{definition}[Irreducible]\label{def:irreducible}
	The set \(S\subseteq \mathcal{\MakeUppercase{v}} \) is \emph{irreducible} if for all \(v\in S\), \(v\) belongs to some cycles in \(G[S]\).
\end{definition}

Now, it's clear that by looking at \(\mathcal{\MakeUppercase{S}} = \left\{ S\subseteq \mathcal{\MakeUppercase{v}} \mid S \text{ is \hyperref[def:irreducible]{irreducible}}\right\} \), we have a \hyperref[def:covering-LP]{covering LP} defined as
\begin{align*}
	\min~ & \sum_{v\in \mathcal{\MakeUppercase{v}} } c(v) x_v                                                                                                          \\
	      & \sum_{v\in S} x_v(d_v^{S} - 1) \geq \left\vert E(S) \right\vert - \left\vert S \right\vert + 1 \eqqcolon b_S\quad \forall S\in \mathcal{\MakeUppercase{S}} \\
	      & x\geq 0.
\end{align*}

We first see why this LP models \autoref{prb:feedback-vertex-set}.

\begin{lemma}\label{lma:lec4-1}
	The integer version of density LP (denote as IP) is equivalent to \autoref{prb:feedback-vertex-set}.
\end{lemma}
\begin{proof}
	If \(x\) is feasible for \autoref{prb:feedback-vertex-set}, then \(x\) is feasible for the IP. On the other hand, if \(x\) is feasible for IP, then for every cycle \(C\in \mathcal{\MakeUppercase{C}} \), \(x\) deletes at least \(1\) vertex from \(C\).
\end{proof}

\subsection{Primal-Dual Method}
Now we're ready to solve this LP via primal-dual method. Denote the dual variables as \(\left\{ y_S \right\} _{S\in \mathcal{\MakeUppercase{S}} }\), then the dual is
\begin{align*}
	\max~ & \sum_{S\in \mathcal{\MakeUppercase{S}} } y_S b_S                                       \\
	      & \sum_{S\ni v}(d_{v} ^S - 1)y_S \leq c(v)\quad \forall v\in \mathcal{\MakeUppercase{v}} \\
	      & y\geq 0.
\end{align*}

\begin{note}
	For the density LP and its dual, the constraint is still exponentially many, and no one knows how to solve this. But the power of primal-dual method is that we don't really solve this, rather, we just maintain two sets of solutions for both primal and dual. Moreover, we can maintain the primal solution in integral, while the dual solution in fractional.
\end{note}

We now have the following algorithm.\par

\begin{algorithm}[H]\label{algo:feedback-vertex-set-PD}
	\DontPrintSemicolon
	\caption{\hyperref[prb:feedback-vertex-set]{Feedback vertex set} -- Primal-Dual}
	\KwData{A graph \(\mathcal{\MakeUppercase{g}} =(\mathcal{\MakeUppercase{v}} , \mathcal{\MakeUppercase{e}} )\)}
	\KwResult{A minimal \hyperref[prb:feedback-vertex-set]{feedback vertex set} \(F^\prime \)}
	\SetKwFunction{reduce}{reduce}
	\BlankLine

	\(S\gets \mathcal{\MakeUppercase{v}} \), \(c^\prime = c\), \(y\gets 0\)\Comment*[r]{\(c^\prime \in \mathbb{\MakeUppercase{r}} ^n\) keeps track of slackness of \(c\)}
	\;
	\While(){\(S \neq \varnothing \)}{
		\(S\gets\) \reduce{\(S\) }\Comment*[r]{Compute \(\left\{ v\in S\colon v\text{ belongs to some cycles in }\mathcal{\MakeUppercase{G}} [S]\right\}\)}
		\((\alpha, v) \gets \min _{v\in S} c^\prime (v) / (d_v^S - 1)\)\footnote{Note that we also get the argument \(v\).}\Comment*[r]{\(y_S\) gets tight by increasing unit weight}
		\(y_S\gets \alpha\)\label{algo:feedback-vertex-set-PD:line6}\;
		\(c^\prime (v)\gets c^\prime (v) - \alpha (d_v^S - 1)\)\label{algo:feedback-vertex-set-PD:line7}\;
		\(Z\gets \left\{ v\in S\colon c^\prime (v) = 0 \right\} \)\;
		\(F\gets F\cup Z\), \(S\gets S \setminus Z\)\;
	}
	\;
	\(F^\prime \gets F\)\Comment*[r]{Compute a minimal \hyperref[prb:feedback-vertex-set]{feedback vertex set}}
	\For(){\(i = \ell , \ldots  , 1\)}{
		\If(){\(F^\prime \setminus \left\{ v_i \right\}\) is a \hyperref[prb:feedback-vertex-set]{feedback vertex set} for \(\mathcal{\MakeUppercase{g}} \) }{
			\(F^\prime \gets F^\prime \setminus \left\{ v_i \right\} \)\;
		}
	}
	\Return{\(F^\prime \)}\;
\end{algorithm}

\begin{claim}
	\(F\) is a \hyperref[prb:feedback-vertex-set]{feedback vertex set} and \(y\) is dual-feasible.
\end{claim}
\begin{explanation}
	It should be clear that why \(F\) is a \hyperref[prb:feedback-vertex-set]{feedback vertex set}. As for the reason why \(y\) is dual-feasible, observe that we have one constraint for each \(v\). After raising \(y_S\) for chosen \(v\) in \autoref{algo:feedback-vertex-set-PD:line6} and deduce \(c^\prime (v)\) in \autoref{algo:feedback-vertex-set-PD:line7}, \(v\) will get removed so the constraint corresponding to \(v\) will be satisfied throughout.
\end{explanation}

We want to compare the primal cost and the dual cost. The primal cost is
\[
	c(F) = \sum_{v\in F}c(v) = \sum_{v\in F}\sum_{S\ni v} (d_{v} ^S - 1) y_S = \sum_{S\in \mathcal{\MakeUppercase{S}}}y_S \sum_{v\in F \cap S}(d_{v} ^S - 1),
\]
while the dual cost is \(\sum_{S\in \mathcal{\MakeUppercase{S}} }y_S b_S\).

\begin{remark}
	This is where the primal-dual method is powerful. i.e., by switching the order of summation, if we have some ratio of \(\sum_{v\in F \cap S}(d_{v} ^S - 1)\) and \(b_S\) for every \(S\), we're done. On caveat is that since \(S\) is changing when running \autoref{algo:feedback-vertex-set-PD}, so the final solution \(F\) may not be good for this particular \(S\). We need to guarantee some ratio for this \(F\) \textbf{for all \(S\)}.\footnote{At least for \(S\) with positive \(y_S\).}
\end{remark}

\begin{lemma}\label{lma:lec4-2}
	For all \(S\in \mathcal{\MakeUppercase{S}} \), if \(F\) is \emph{minimal} in \(S\),\footnote{i.e., in \(\mathcal{\MakeUppercase{g}} [S]\), no \(F^\prime \subsetneq F \cap S\) in \hyperref[prb:feedback-vertex-set]{feedback vertex set}.} then we have
	\[
		\sum_{v\in S \cap F}(d_{v} ^S - 1) \leq 4\cdot b_S = 4(\left\vert E(S) \right\vert - \left\vert S \right\vert + 1).
	\]
\end{lemma}
\begin{proof}
	Let's first see a simple case.
	\begin{intuition}
		If the graph is \(3\)-regular, then we see that the left-hand side is \(\leq 2\cdot \left\vert S \right\vert \) by summing over the whole \(S\) instead of \(S\cap F\), while the right-hand side is \(2\cdot \left\vert S \right\vert + 4\) since \(\left\vert E(S) \right\vert = 1.5 \left\vert S \right\vert \).

		This shows that in a \(3\)-regular graph, deleting every vertex in \(S\) is actually \(4\)-approximated. And this intuition generalized to general graph with degree greater than \(3\).
	\end{intuition}

	Since we assume \(S\) to be \hyperref[def:irreducible]{irreducible}, so we're not interested in degree \(0\) or \(1\) vertices (there are no such vertices in an \hyperref[def:irreducible]{irreducible} \(S\)). So the only problematic guy is degree-\(2\) vertex. And the only place a degree-\(2\) vertex can live is in a long path.

	\begin{figure}[H]
		\centering
		\incfig{FBV-path}
		\caption{If there are two \(v\in F\), by minimality of \(F\), one of \(v\) will be strictly unnecessary to break this path in a cycle.}
		\label{fig:FBV-path}
	\end{figure}
	\begin{note}
		Observe that we only need to delete at most one vertex in any path, and sometimes this may be loose since we can delete one branch node joining two paths, i.e., deleting \(1\) nodes for two paths.
	\end{note}

	Let \(A\) be the set of degree \(2\) vertices, and \(B\) be the set of vertices with degree larger than \(3\). Now, consider line segment in the graph. If \(\ell \) is a line segment,
	\begin{enumerate}[(a)]
		\item \(\left\vert F \cap  \ell  \right\vert \leq 1\)
		\item If \(F\) contains one of the endpoints of \(\ell \), then \(\left\vert F \cap \ell  \right\vert = 0\)
	\end{enumerate}

	Since \(F\) is minimal, the left-hand side is
	\[
		\left\vert A \cap  F \right\vert + \sum_{v\in B \cap F}(d_{v} ^S - 1) \leq \sum_{v\in B \setminus F} d_{v} ^S / 2 + \sum_{v\in B \cap F}(d_{v} ^S - 1) \leq \sum_{v\in B}(d_{v}^S - 1 ),
	\]
	while the right-hand side is
	\[
		\left\vert E(S) \right\vert - \left\vert S \right\vert = \sum_{v\in S}(d_{v} ^S / 2 - 1) = \sum_{v\in B} (d_{v} ^S / 2 - 1).
	\]
	It's clear that since \(\forall v\in B\), \(d_v^S - 1 \leq 4 (d_{v} ^S / 2 - 1)\), rearranging this inequality gives the result.
\end{proof}

To show \autoref{thm:lec4-1}, it's enough to have a minimal \(F\), then the result follows form \autoref{lma:lec4-1}. Hence, after obtaining \(F\), \autoref{algo:feedback-vertex-set-PD} further convert \(F\) into \(F^\prime \) and  try to obtain a minimal version of \(F\). Clearly, \(F^\prime \) is still a \hyperref[prb:feedback-vertex-set]{feedback vertex set}, and the minimality of \(F^\prime \) is guaranteed by the following lemma.

\begin{lemma}\label{lma:lec4-3}
	\(F^\prime \) is minimal in every \(S_i\), where \(S_i = S\) when \(v_i\) is deleted.
\end{lemma}
\begin{proof}
	Suppose this is not the case. Then there exists \(v_j\in F^\prime \) such that in \(\mathcal{\MakeUppercase{g}} [S_i]\), \(b_S= \cap S_i\setminus \left\{ v_{j}  \right\}\) is still a \hyperref[prb:feedback-vertex-set]{feedback vertex set}. This means \(\left\vert F \cap S_j \right\vert \setminus \left\{ v_{j}  \right\}  \) is still a \hyperref[prb:feedback-vertex-set]{feedback vertex set} in \(\mathcal{\MakeUppercase{g}} [S_j]\).

	Observe that there are no \(C\ni v_j\) such that \(C\setminus S_j\) is disjoint from \(F\), which further implies \(F^\prime \setminus \left\{ v_j \right\} \) is still a \hyperref[prb:feedback-vertex-set]{feedback vertex set} in \(\mathcal{\MakeUppercase{g}} \) when \(i = j\) in \autoref{algo:feedback-vertex-set-PD}.
\end{proof}

Finally, we see that we can prove \autoref{thm:lec4-1}.

\begin{proof}[Proof of \autoref{thm:lec4-1}]
	Firstly, \autoref{algo:feedback-vertex-set-PD} gives a \(4\)-approximation of the density IP guaranteed by \autoref{lma:lec4-2} and \autoref{lma:lec4-3}. Finally, from \autoref{lma:lec4-1}, we see that \ autoref{prb:feedback-vertex-set} and the density IP is equivalent, proving the theorem.
\end{proof}